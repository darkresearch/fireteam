---
title: "Architecture"
description: "Deep dive into Fireteam's multi-agent orchestration architecture and cycle-based execution model"
---

## System Overview

Fireteam is built on a **multi-agent orchestration architecture** where specialized AI agents work in coordinated cycles to build complete software projects autonomously.

```
┌─────────────────────────────────────────────────────────┐
│                    ORCHESTRATOR                         │
│                  (Infinite Loop)                        │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
         ┌────────────────────────────────┐
         │      CYCLE N (repeats)         │
         └────────────────────────────────┘
                          │
         ┌────────────────┼────────────────┐
         │                │                │
         ▼                ▼                ▼
    ┌────────┐      ┌──────────┐     ┌──────────┐
    │ PLANNER│      │ EXECUTOR │     │ REVIEWER │
    │ Agent  │  →   │  Agent   │  →  │  Agent   │
    └────────┘      └──────────┘     └──────────┘
         │                │                │
         └────────────────┼────────────────┘
                          │
                          ▼
                   ┌─────────────┐
                   │ GIT COMMIT  │
                   └─────────────┘
                          │
                          ▼
                ┌──────────────────────┐
                │  ≥95% for 3 cycles?  │
                │   Yes → Complete     │
                │   No  → Next Cycle   │
                └──────────────────────┘
```

## Core Components

### 1. Orchestrator

The **Orchestrator** (`orchestrator.py`) is the mission commander that coordinates all agents and manages the execution loop.

**Responsibilities**:
- Initialize and validate Git repository
- Load and manage project state
- Execute agents in sequence (Planner → Executor → Reviewer)
- Handle agent failures and retries
- Create Git commits after each cycle
- Validate completion criteria (3 consecutive 95%+ reviews)
- Manage graceful shutdown

**Key Features**:
- **Infinite loop** until completion or manual stop
- **State persistence** between cycles
- **Error recovery** with configurable retries
- **Signal handling** for graceful shutdown (SIGTERM, SIGINT)

```python
# Simplified orchestrator loop
while not completion_validated:
    # Plan phase
    plan = planner_agent.execute(goal, prev_plan, last_review)

    # Execute phase
    execution_result = executor_agent.execute(plan, goal)

    # Review phase
    review = reviewer_agent.execute(goal, plan, execution_result)

    # Git commit
    git_commit(cycle_number, completion_percentage)

    # Check completion
    if review.completion >= 95:
        validation_count += 1
        if validation_count >= 3:
            completion_validated = True
    else:
        validation_count = 0

    cycle_number += 1
```

### 2. State Manager

The **State Manager** (`state/manager.py`) provides isolated state management for each project.

**State Schema**:
```json
{
  "project_dir": "/absolute/path/to/project",
  "goal": "Project objective description",
  "status": "planning|executing|reviewing|completed",
  "cycle_number": 0,
  "completion_percentage": 0,
  "validation_checks": 0,
  "git_branch": "agent-20251017-143022",
  "current_plan": "Latest plan from Planner agent",
  "last_execution_result": "Latest Executor output",
  "last_review": "Latest Reviewer output",
  "created_at": "2025-10-17T14:30:22Z",
  "updated_at": "2025-10-17T15:45:33Z"
}
```

**State Isolation**:
- State is **completely reset** between projects
- Prevents cross-contamination of goals, plans, or context
- Each project starts fresh with no residual data

<Warning>
State files are stored in `state/current.json` and are gitignored. Never commit state files.
</Warning>

### 3. Specialized Agents

Three specialized agents handle different phases of development:

<CardGroup cols={3}>
  <Card title="Planner Agent" icon="map">
    Creates and updates project plans based on goals and progress
  </Card>
  <Card title="Executor Agent" icon="code">
    Implements tasks from the plan with production-ready code
  </Card>
  <Card title="Reviewer Agent" icon="magnifying-glass">
    Tests functionality and estimates completion percentage
  </Card>
</CardGroup>

Each agent is a **subclass of BaseAgent** (`agents/base.py`) and implements:
- Specialized prompt generation
- Claude CLI invocation
- Output parsing and validation
- Timeout management
- Retry logic

Learn more about agents in the [Agents](/core-concepts/agents) documentation.

## Execution Flow

### Phase 1: Initialization

When you run `start-agent`, the orchestrator:

1. **Validates the project directory**
   - Creates directory if it doesn't exist
   - Checks for write permissions

2. **Initializes Git repository**
   - Runs `git init` if not already a repo
   - Creates timestamped branch (e.g., `agent-20251017-143022`)
   - Makes initial commit with Fireteam metadata

3. **Loads or creates state**
   - Checks for existing `state/current.json`
   - Creates fresh state for new projects
   - Validates state schema

4. **Configures Git**
   - Sets user name and email from environment or config
   - Configures branch tracking

### Phase 2: Cycle Execution

Each cycle consists of four phases:

#### Planning (Planner Agent)

**Input**:
- Project goal (constant across all cycles)
- Previous plan (if any)
- Last review output (if any)
- Current cycle number

**Process**:
- Analyzes what's been built so far
- Reviews feedback from the Reviewer
- Creates or updates actionable task list
- Prioritizes remaining work

**Output**:
- Structured project plan
- Task breakdown
- Implementation guidance

**Timeout**: 10 minutes (configurable)

#### Execution (Executor Agent)

**Input**:
- Current plan from Planner
- Project goal
- Project directory path

**Process**:
- Reads the plan and goal
- Implements tasks with actual working code
- Creates files, writes tests, adds documentation
- Runs tests to verify functionality

**Output**:
- Working code implementations
- Test files
- Documentation updates
- Summary of work completed

**Timeout**: 30 minutes (configurable)

<Tip>
The Executor has the longest timeout because implementation is the most time-intensive phase, especially for complex projects.
</Tip>

#### Review (Reviewer Agent)

**Input**:
- Project goal
- Current plan
- Execution result summary
- Project directory path

**Process**:
- Scans the entire codebase
- Runs tests and checks functionality
- Compares against the goal
- Identifies gaps or issues
- Calculates completion percentage (0-100%)

**Output**:
- Completion percentage (0-100%)
- List of completed features
- List of remaining work
- Quality assessment

**Timeout**: 10 minutes (configurable)

#### Git Commit

After each cycle, the orchestrator:

1. **Stages all changes**
   ```bash
   git add -A
   ```

2. **Creates descriptive commit**
   ```bash
   git commit -m "Cycle N: <summary of changes>"
   ```

3. **Pushes to remote** (if origin exists)
   ```bash
   git push -u origin <branch-name>
   ```

This creates a complete audit trail of the project's development.

### Phase 3: Validation

After the Review phase, the orchestrator checks completion:

```python
if completion_percentage >= 95:
    validation_checks += 1

    if validation_checks >= 3:
        # Project complete!
        mark_as_completed()
        shutdown()
    else:
        # Continue validation cycles
        continue_to_next_cycle()
else:
    # Reset validation counter
    validation_checks = 0
    continue_to_next_cycle()
```

**Why 3 consecutive checks?**

A single high score could be a false positive. Three consecutive ≥95% reviews ensure:
- Consistent quality across cycles
- No regression in functionality
- Thorough validation from multiple angles
- Genuine project completion

<Info>
The Reviewer is instructed to take a **fresh, critical look** each time, not just rubber-stamp previous assessments.
</Info>

## Data Flow

### Information Passing Between Agents

Agents don't communicate directly. The orchestrator passes outputs as inputs:

```
Cycle N:
  Planner Input: (goal, plan[N-1], review[N-1])
     ↓
  Planner Output: plan[N]
     ↓
  Executor Input: (goal, plan[N])
     ↓
  Executor Output: execution_result[N]
     ↓
  Reviewer Input: (goal, plan[N], execution_result[N])
     ↓
  Reviewer Output: review[N] (includes completion %)
     ↓
  State Update: Save all outputs to state.json
     ↓
  Git Commit: Commit all file changes
```

### State Persistence

After each agent execution, state is saved to disk:

```python
state_manager.update({
    "cycle_number": current_cycle,
    "status": "reviewing",  # or "planning", "executing"
    "current_plan": plan_output,
    "last_execution_result": execution_output,
    "last_review": review_output,
    "completion_percentage": review.completion,
    "validation_checks": validation_count,
    "updated_at": datetime.now().isoformat()
})
```

This enables:
- **Crash recovery**: Restart from last saved state
- **Progress monitoring**: External tools can read state
- **Debugging**: Examine state at any point

## Git Integration

### Repository Structure

Fireteam creates this Git structure:

```
project-dir/
├── .git/
│   └── (Fireteam-managed Git repo)
├── src/
│   └── (Agent-written code)
├── tests/
│   └── (Agent-written tests)
├── README.md (Agent-written docs)
├── requirements.txt (or package.json)
└── (other agent-created files)
```

### Branch Strategy

Fireteam uses **timestamped feature branches**:

```
main (untouched)
  │
  └── agent-20251017-143022 (Fireteam working branch)
```

**Benefits**:
- Main branch stays clean
- Easy to compare before/after
- Multiple Fireteam runs create separate branches
- You decide when to merge to main

### Commit Messages

Automatic commits follow this format:

```
Cycle 0: Initial implementation with API integration

- Created main application structure
- Implemented CoinGecko API client
- Added error handling and retries
- Wrote initial test suite

Completion: 88%
```

Clear, descriptive, and includes completion percentage.

## Error Handling

### Agent Failure Recovery

When an agent fails (timeout, error, crash):

1. **Retry Logic**: Up to 3 retries with exponential backoff
2. **State Preservation**: Current state is saved before retry
3. **Logging**: Detailed error logs in `logs/orchestrator_*.log`
4. **Graceful Degradation**: If all retries fail, stop gracefully

```python
for attempt in range(MAX_RETRIES):
    try:
        result = agent.execute()
        return result
    except TimeoutError:
        if attempt < MAX_RETRIES - 1:
            time.sleep(RETRY_DELAY * (2 ** attempt))  # Exponential backoff
            continue
        else:
            raise
```

### Parse Failure Handling

If the Reviewer's output can't be parsed (invalid format):

- **Use last known completion %**: Prevents completion from resetting to 0%
- **Log warning**: Alert but don't crash
- **Continue cycle**: Allow system to self-correct

### State Corruption Recovery

If `state/current.json` is corrupted:

1. Stop the agent: `stop-agent`
2. Remove corrupt state: `rm state/current.json`
3. Restart with fresh state

The Git history is preserved, so no code is lost.

## Scalability & Performance

### Resource Management

**CPU**: Light usage - primarily orchestration logic
**Memory**: ~100-500MB depending on project size
**Disk**: Logs and state files (typically &lt;100MB)
**Network**: Claude API calls (minimal bandwidth)

### Timing Characteristics

Based on real test data:

- **Single-cycle projects**: 20-30 minutes
- **Typical projects (2-3 cycles)**: 45-90 minutes
- **Complex projects (5+ cycles)**: 2-4 hours
- **Average**: ~50 minutes per project

### Bottlenecks

**Primary bottleneck**: Agent execution time (Claude API)

**Mitigation strategies**:
- Optimized timeouts per agent role
- Retry logic with exponential backoff
- State caching to avoid redundant work

## Security Considerations

### Dangerous Permissions Flag

Fireteam uses `--dangerously-skip-permissions` with Claude CLI to enable fully autonomous operation.

<Warning>
This allows agents to execute any command without confirmation. Only use Fireteam in isolated environments or with projects you trust.
</Warning>

### Sudo Operations

Some operations (Node.js installation, system packages) may require sudo:

- **Option 1**: Configure passwordless sudo (see [Sudo Setup](/configuration/sudo-setup))
- **Option 2**: Set `SUDO_PASSWORD` in `.env` file

**Security Note**: Never commit `.env` with passwords to Git.

### Git Credentials

If pushing to remote repositories, ensure:
- SSH keys are configured, OR
- Git credential helper is set up
- Fireteam will push to `origin` if it exists

## Next Steps

<CardGroup cols={2}>
  <Card title="Learn About Agents" icon="robot" href="/core-concepts/agents">
    Deep dive into Planner, Executor, and Reviewer agents
  </Card>

  <Card title="Understand Cycles" icon="rotate" href="/core-concepts/cycles">
    How cycles work and validation logic
  </Card>

  <Card title="Configure Timeouts" icon="clock" href="/configuration/timeouts">
    Optimize agent timeouts for your projects
  </Card>

  <Card title="State Management" icon="database" href="/advanced/state-management">
    Advanced state management patterns
  </Card>
</CardGroup>
