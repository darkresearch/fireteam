---
title: "API Overview"
description: "Technical reference for Fireteam's Python architecture"
---

## Overview

Fireteam is built as a modular Python system with clean separation between orchestration, agent execution, and state management. This section provides technical documentation for developers who want to understand or extend Fireteam's internals.

## Architecture Components

<CardGroup cols={2}>

<Card title="Orchestrator" icon="diagram-project">
  Main control loop managing agent lifecycle and cycle execution
</Card>

<Card title="Agents" icon="robot">
  Specialized agents (Planner, Executor, Reviewer) powered by Claude
</Card>

<Card title="State Manager" icon="database">
  Persistent state management with isolation and recovery
</Card>

<Card title="Configuration" icon="gear">
  Centralized configuration via config.py
</Card>

</CardGroup>

## Project Structure

```
fireteam/
├── src/                    # Source code directory
│   ├── orchestrator.py    # Main orchestration loop
│   ├── config.py          # System configuration
│   ├── __init__.py
│   ├── agents/
│   │   ├── __init__.py
│   │   ├── base.py        # Base agent class
│   │   ├── planner.py     # Planner agent implementation
│   │   ├── executor.py    # Executor agent implementation
│   │   └── reviewer.py    # Reviewer agent implementation
│   ├── state/
│   │   ├── __init__.py
│   │   └── manager.py     # State management module
│   └── memory/
│       ├── __init__.py
│       └── manager.py     # Memory system with embeddings
├── state/                 # Runtime state data (gitignored)
│   └── current.json       # Active project state
├── memory/                # Memory storage (gitignored)
│   └── {project_hash}/    # Per-project vector database
├── cli/
│   ├── start-agent        # Start command
│   ├── stop-agent         # Stop command
│   └── fireteam-status    # Status tool
├── tests/                 # Comprehensive test suite (165 tests)
│   ├── pytest.ini
│   ├── conftest.py
│   └── test_*.py
└── logs/                  # Orchestrator logs
```

## Core Classes

### Orchestrator

Main control class managing the agent system lifecycle.

**Location:** `/home/claude/fireteam/src/orchestrator.py`

**Key methods:**
- `__init__(project_dir, goal, debug, keep_memory)` - Initialize orchestrator
- `run()` - Main execution loop
- `run_cycle(state)` - Execute single cycle
- `check_completion(state)` - Validation logic
- `commit_changes(cycle, message)` - Git integration

**Usage:**
```python
orchestrator = Orchestrator(
    project_dir="/home/claude/project",
    goal="Build a CLI calculator",
    debug=False,
    keep_memory=False
)
orchestrator.run()
```

### BaseAgent

Abstract base class for all agents.

**Location:** `/home/claude/fireteam/src/agents/base.py`

**Key methods:**
- `execute(**kwargs)` - Main execution method (template method pattern)
- `_do_execute(**kwargs)` - Subclass implementation (abstract)
- `_execute_with_sdk(prompt, cwd)` - Claude Agent SDK interaction
- `_retrieve_and_format_memories()` - Automatic memory retrieval
- `_build_memory_context_query()` - Build context for memory search

**Features:**
- Automatic memory injection into agent context
- Retry logic with exponential backoff
- Timeout management per agent type
- Template method pattern for consistent behavior

### PlannerAgent

Creates and updates project plans.

**Location:** `/home/claude/fireteam/src/agents/planner.py`

**Input:**
- `goal`: Project objective
- `cycle_number`: Current cycle
- `previous_plan`: Last plan (if any)
- `last_execution_result`: Executor output
- `last_review`: Reviewer feedback

**Output:**
- `plan`: Structured project plan

### ExecutorAgent

Implements tasks from the plan.

**Location:** `/home/claude/fireteam/src/agents/executor.py`

**Input:**
- `goal`: Project objective
- `plan`: Current plan to execute
- `cycle_number`: Current cycle

**Output:**
- `execution_result`: Summary of work done

### ReviewerAgent

Reviews code and estimates completion.

**Location:** `/home/claude/fireteam/src/agents/reviewer.py`

**Input:**
- `goal`: Project objective
- `plan`: Current plan
- `execution_result`: What was implemented
- `cycle_number`: Current cycle
- `is_validation`: Whether in validation mode

**Output:**
- `review`: Review text
- `completion_percentage`: Estimated completion (0-100)

### StateManager

Manages project state persistence.

**Location:** `/home/claude/fireteam/src/state/manager.py`

**Key methods:**
- `initialize_project(dir, goal)` - Create fresh state
- `load_state()` - Load current state
- `update_state(updates)` - Update state fields
- `update_completion_percentage(pct, logger)` - Update with parse failure handling
- `increment_cycle()` - Advance cycle counter
- `mark_completed()` - Mark project complete
- `clear_state()` - Reset state

### MemoryManager

Manages project memory with semantic search.

**Location:** `/home/claude/fireteam/src/memory/manager.py`

**Key methods:**
- `initialize_project(dir, goal)` - Create memory collection
- `add_memory(content, memory_type, cycle, metadata)` - Store memory
- `search(query, limit, memory_types)` - Semantic search
- `clear_project_memory(dir)` - Clean up memory

**Features:**
- Local vector database (ChromaDB)
- Semantic search with Qwen3 embeddings
- Project isolation via hashing
- Automatic cleanup

## Configuration System

### config.py Structure

```python
# System paths
SYSTEM_DIR = os.getenv("FIRETEAM_DIR", "/home/claude/fireteam")
STATE_DIR = os.path.join(SYSTEM_DIR, "state")
LOGS_DIR = os.path.join(SYSTEM_DIR, "logs")
MEMORY_DIR = os.path.join(SYSTEM_DIR, "memory")

# Claude Agent SDK configuration
SDK_ALLOWED_TOOLS = ["Read", "Write", "Bash", "Edit", "Grep", "Glob"]
SDK_PERMISSION_MODE = "bypassPermissions"
SDK_MODEL = os.getenv("ANTHROPIC_MODEL", "claude-sonnet-4-5-20250929")

# Agent timeouts (seconds)
DEFAULT_TIMEOUT = int(os.getenv("FIRETEAM_DEFAULT_TIMEOUT", "600"))
AGENT_TIMEOUTS = {
    "planner": int(os.getenv("FIRETEAM_AGENT_TIMEOUT_PLANNER", DEFAULT_TIMEOUT)),
    "reviewer": int(os.getenv("FIRETEAM_AGENT_TIMEOUT_REVIEWER", DEFAULT_TIMEOUT)),
    "executor": int(os.getenv("FIRETEAM_AGENT_TIMEOUT_EXECUTOR", str(DEFAULT_TIMEOUT * 3)))
}

# Completion thresholds
COMPLETION_THRESHOLD = 95
VALIDATION_CHECKS_REQUIRED = 3

# Memory configuration
MEMORY_EMBEDDING_MODEL = "Qwen/Qwen3-Embedding-0.6B"
MEMORY_SEARCH_LIMIT = 10

# Git configuration
GIT_USER_NAME = os.environ.get("GIT_USER_NAME", "fireteam")
GIT_USER_EMAIL = os.environ.get("GIT_USER_EMAIL", "fireteam@darkresearch.ai")

# Logging
LOG_LEVEL = os.getenv("LOG_LEVEL", os.getenv("FIRETEAM_LOG_LEVEL", "INFO")).upper()
```

See [Configuration Reference](/configuration/config-file) for details.

## Agent Communication Flow

```
Orchestrator
    ↓ (passes goal, context)
PlannerAgent → creates plan
    ↓ (passes plan, goal)
ExecutorAgent → implements plan
    ↓ (passes execution result, plan)
ReviewerAgent → reviews & estimates completion
    ↓ (passes completion %)
Orchestrator → checks validation → commits to git → next cycle
```

## Extending Fireteam

### Adding a Custom Agent

```python
# agents/custom_agent.py
from agents.base import BaseAgent

class CustomAgent(BaseAgent):
    def __init__(self, logger):
        super().__init__("custom", logger)

    def execute(self, **kwargs):
        prompt = self._build_prompt(**kwargs)
        output = self._call_claude(prompt, kwargs['project_dir'])
        result = self._parse_output(output)

        return {
            "success": True,
            "custom_result": result
        }
```

### Modifying Agent Prompts

Agent prompts are built in each agent's `_build_prompt()` method:

```python
# agents/planner.py
def _build_prompt(self, goal, cycle_number, ...):
    return f"""
    You are a planning agent for project: {goal}

    Current cycle: {cycle_number}

    Previous plan: {previous_plan}

    Create an updated plan...
    """
```

### Custom State Fields

```python
# Extend state with custom fields
state_manager.update_state({
    "custom_metric": 42,
    "custom_flag": True
})
```

## API Examples

### Programmatic Project Execution

```python
import sys
sys.path.insert(0, '/home/claude/fireteam/src')

from orchestrator import Orchestrator

# Create orchestrator
orch = Orchestrator(
    project_dir="/home/claude/my-project",
    goal="Build a Python CLI calculator"
)

# Run project
exit_code = orch.run()

print(f"Project completed with exit code: {exit_code}")
```

### Reading State Programmatically

```python
import json

with open('/home/claude/fireteam/state/current.json') as f:
    state = json.load(f)

print(f"Cycle: {state['cycle_number']}")
print(f"Completion: {state['completion_percentage']}%")
```

### Custom Logging

```python
import logging

# Configure custom logger
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('custom.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger("fireteam-custom")
```

## Integration Points

### Git Integration

Fireteam automatically:
- Initializes git repo if needed
- Creates timestamped branch
- Commits after each cycle
- Pushes to remote (if configured)

**Manual git operations:**
```python
# In orchestrator.py
def commit_changes(self, cycle_number, message_suffix):
    subprocess.run(["git", "add", "."], cwd=self.project_dir)
    subprocess.run(
        ["git", "commit", "-m", f"Cycle {cycle_number}: {message_suffix}"],
        cwd=self.project_dir
    )
```

### Claude Agent SDK Integration

All agents use the Claude Agent SDK:
```python
# Base agent method
async def _execute_with_sdk(self, prompt, project_dir):
    from claude_agent_sdk import ClaudeSDKClient, ClaudeAgentOptions
    
    # Configure SDK options
    options = ClaudeAgentOptions(
        allowed_tools=config.SDK_ALLOWED_TOOLS,
        permission_mode=config.SDK_PERMISSION_MODE,
        model=config.SDK_MODEL,
        cwd=project_dir,
        system_prompt=self.get_system_prompt()
    )
    
    # Execute with SDK
    async with ClaudeSDKClient(options=options) as client:
        await client.query(prompt)
        async for message in client.receive_response():
            # Process response...
```

**Note**: API key is read from `ANTHROPIC_API_KEY` environment variable.

## Error Handling

### Retry Logic

```python
# config.py
MAX_RETRIES = 3
RETRY_DELAY = 5  # seconds

# Implemented in agents
for attempt in range(MAX_RETRIES):
    try:
        return self._call_claude(prompt, cwd)
    except subprocess.TimeoutExpired:
        if attempt < MAX_RETRIES - 1:
            time.sleep(RETRY_DELAY)
            continue
        raise
```

### Graceful Degradation

- Agent failures don't crash orchestrator
- State preserved on errors
- Logged for debugging
- Manual intervention possible

## Testing

### Running Unit Tests

```python
# tests/test_state_manager.py
import pytest
from state.manager import StateManager

def test_state_initialization():
    sm = StateManager()
    state = sm.initialize_project("/tmp/test", "Test goal")
    assert state["cycle_number"] == 0
    assert state["goal"] == "Test goal"
```

### Mock Agent Testing

```python
# tests/test_orchestrator.py
from unittest.mock import Mock, patch

def test_cycle_execution():
    with patch('agents.planner.PlannerAgent') as mock_planner:
        mock_planner.return_value.execute.return_value = {
            "success": True,
            "plan": "Test plan"
        }
        # Test orchestrator cycle...
```

## Next Steps

<CardGroup cols={2}>

<Card title="State Manager API" icon="database" href="/api/state-manager">
  Detailed StateManager class documentation
</Card>

<Card title="Agents API" icon="robot" href="/api/agents">
  Agent class hierarchy and methods
</Card>

<Card title="Configuration API" icon="gear" href="/api/configuration">
  Configuration system reference
</Card>

<Card title="GitHub" icon="github" href="https://github.com/darkresearch/fireteam">
  View source code
</Card>

</CardGroup>
