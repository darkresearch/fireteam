---
title: "API Overview"
description: "Technical reference for Fireteam's Python architecture"
---

## Overview

Fireteam is built as a modular Python system with clean separation between orchestration, agent execution, and state management. This section provides technical documentation for developers who want to understand or extend Fireteam's internals.

## Architecture Components

<CardGroup cols={2}>

<Card title="Orchestrator" icon="diagram-project">
  Main control loop managing agent lifecycle and cycle execution
</Card>

<Card title="Agents" icon="robot">
  Specialized agents (Planner, Executor, Reviewer) powered by Claude
</Card>

<Card title="State Manager" icon="database">
  Persistent state management with isolation and recovery
</Card>

<Card title="Configuration" icon="gear">
  Centralized configuration via config.py
</Card>

</CardGroup>

## Project Structure

```
fireteam/
├── orchestrator.py         # Main orchestration loop
├── config.py              # System configuration
├── agents/
│   ├── __init__.py
│   ├── base.py           # Base agent class
│   ├── planner.py        # Planner agent implementation
│   ├── executor.py       # Executor agent implementation
│   └── reviewer.py       # Reviewer agent implementation
├── state/
│   ├── manager.py        # State management
│   └── current.json      # Active state (gitignored)
├── cli/
│   ├── start-agent       # Start command
│   ├── stop-agent        # Stop command
│   └── fireteam-status   # Status tool
└── logs/                 # Orchestrator logs
```

## Core Classes

### Orchestrator

Main control class managing the agent system lifecycle.

**Location:** `/home/claude/fireteam/orchestrator.py`

**Key methods:**
- `__init__(project_dir, goal)` - Initialize orchestrator
- `run()` - Main execution loop
- `run_cycle(state)` - Execute single cycle
- `check_completion(state)` - Validation logic
- `commit_changes(cycle, message)` - Git integration

**Usage:**
```python
orchestrator = Orchestrator(
    project_dir="/home/claude/project",
    goal="Build a CLI calculator"
)
orchestrator.run()
```

### BaseAgent

Abstract base class for all agents.

**Location:** `/home/claude/fireteam/agents/base.py`

**Key methods:**
- `execute(**kwargs)` - Main execution method (abstract)
- `_call_claude(prompt, cwd)` - Claude CLI interaction
- `_parse_output(output)` - Output parsing

### PlannerAgent

Creates and updates project plans.

**Location:** `/home/claude/fireteam/agents/planner.py`

**Input:**
- `goal`: Project objective
- `cycle_number`: Current cycle
- `previous_plan`: Last plan (if any)
- `last_execution_result`: Executor output
- `last_review`: Reviewer feedback

**Output:**
- `plan`: Structured project plan

### ExecutorAgent

Implements tasks from the plan.

**Location:** `/home/claude/fireteam/agents/executor.py`

**Input:**
- `goal`: Project objective
- `plan`: Current plan to execute
- `cycle_number`: Current cycle

**Output:**
- `execution_result`: Summary of work done

### ReviewerAgent

Reviews code and estimates completion.

**Location:** `/home/claude/fireteam/agents/reviewer.py`

**Input:**
- `goal`: Project objective
- `plan`: Current plan
- `execution_result`: What was implemented
- `cycle_number`: Current cycle
- `is_validation`: Whether in validation mode

**Output:**
- `review`: Review text
- `completion_percentage`: Estimated completion (0-100)

### StateManager

Manages project state persistence.

**Location:** `/home/claude/fireteam/state/manager.py`

**Key methods:**
- `initialize_project(dir, goal)` - Create fresh state
- `load_state()` - Load current state
- `update_state(updates)` - Update state fields
- `increment_cycle()` - Advance cycle counter
- `mark_completed()` - Mark project complete

## Configuration System

### config.py Structure

```python
# System paths
SYSTEM_DIR = "/home/claude/fireteam"
STATE_DIR = os.path.join(SYSTEM_DIR, "state")
LOGS_DIR = os.path.join(SYSTEM_DIR, "logs")

# Agent timeouts (seconds)
AGENT_TIMEOUTS = {
    "planner": 600,
    "reviewer": 600,
    "executor": 1800
}

# Completion thresholds
COMPLETION_THRESHOLD = 95
VALIDATION_CHECKS_REQUIRED = 3

# Git configuration
GIT_USER_NAME = os.environ.get("GIT_USER_NAME", "fireteam")
GIT_USER_EMAIL = os.environ.get("GIT_USER_EMAIL", "fireteam@darkresearch.ai")

# Optional sudo password
SUDO_PASSWORD = os.getenv("SUDO_PASSWORD", None)
```

See [Configuration Reference](/configuration/config-file) for details.

## Agent Communication Flow

```
Orchestrator
    ↓ (passes goal, context)
PlannerAgent → creates plan
    ↓ (passes plan, goal)
ExecutorAgent → implements plan
    ↓ (passes execution result, plan)
ReviewerAgent → reviews & estimates completion
    ↓ (passes completion %)
Orchestrator → checks validation → commits to git → next cycle
```

## Extending Fireteam

### Adding a Custom Agent

```python
# agents/custom_agent.py
from agents.base import BaseAgent

class CustomAgent(BaseAgent):
    def __init__(self, logger):
        super().__init__("custom", logger)

    def execute(self, **kwargs):
        prompt = self._build_prompt(**kwargs)
        output = self._call_claude(prompt, kwargs['project_dir'])
        result = self._parse_output(output)

        return {
            "success": True,
            "custom_result": result
        }
```

### Modifying Agent Prompts

Agent prompts are built in each agent's `_build_prompt()` method:

```python
# agents/planner.py
def _build_prompt(self, goal, cycle_number, ...):
    return f"""
    You are a planning agent for project: {goal}

    Current cycle: {cycle_number}

    Previous plan: {previous_plan}

    Create an updated plan...
    """
```

### Custom State Fields

```python
# Extend state with custom fields
state_manager.update_state({
    "custom_metric": 42,
    "custom_flag": True
})
```

## API Examples

### Programmatic Project Execution

```python
import sys
sys.path.insert(0, '/home/claude/fireteam')

from orchestrator import Orchestrator

# Create orchestrator
orch = Orchestrator(
    project_dir="/home/claude/my-project",
    goal="Build a Python CLI calculator"
)

# Run project
exit_code = orch.run()

print(f"Project completed with exit code: {exit_code}")
```

### Reading State Programmatically

```python
import json

with open('/home/claude/fireteam/state/current.json') as f:
    state = json.load(f)

print(f"Cycle: {state['cycle_number']}")
print(f"Completion: {state['completion_percentage']}%")
```

### Custom Logging

```python
import logging

# Configure custom logger
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('custom.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger("fireteam-custom")
```

## Integration Points

### Git Integration

Fireteam automatically:
- Initializes git repo if needed
- Creates timestamped branch
- Commits after each cycle
- Pushes to remote (if configured)

**Manual git operations:**
```python
# In orchestrator.py
def commit_changes(self, cycle_number, message_suffix):
    subprocess.run(["git", "add", "."], cwd=self.project_dir)
    subprocess.run(
        ["git", "commit", "-m", f"Cycle {cycle_number}: {message_suffix}"],
        cwd=self.project_dir
    )
```

### Claude CLI Integration

All agents use:
```python
# Base agent method
def _call_claude(self, prompt, cwd):
    result = subprocess.run(
        [
            "claude",
            "--dangerously-skip-permissions",
            "--prompt", prompt,
            "--cwd", cwd
        ],
        capture_output=True,
        text=True,
        timeout=self.timeout
    )
    return result.stdout
```

## Error Handling

### Retry Logic

```python
# config.py
MAX_RETRIES = 3
RETRY_DELAY = 5  # seconds

# Implemented in agents
for attempt in range(MAX_RETRIES):
    try:
        return self._call_claude(prompt, cwd)
    except subprocess.TimeoutExpired:
        if attempt < MAX_RETRIES - 1:
            time.sleep(RETRY_DELAY)
            continue
        raise
```

### Graceful Degradation

- Agent failures don't crash orchestrator
- State preserved on errors
- Logged for debugging
- Manual intervention possible

## Testing

### Running Unit Tests

```python
# tests/test_state_manager.py
import pytest
from state.manager import StateManager

def test_state_initialization():
    sm = StateManager()
    state = sm.initialize_project("/tmp/test", "Test goal")
    assert state["cycle_number"] == 0
    assert state["goal"] == "Test goal"
```

### Mock Agent Testing

```python
# tests/test_orchestrator.py
from unittest.mock import Mock, patch

def test_cycle_execution():
    with patch('agents.planner.PlannerAgent') as mock_planner:
        mock_planner.return_value.execute.return_value = {
            "success": True,
            "plan": "Test plan"
        }
        # Test orchestrator cycle...
```

## Next Steps

<CardGroup cols={2}>

<Card title="State Manager API" icon="database" href="/api/state-manager">
  Detailed StateManager class documentation
</Card>

<Card title="Agents API" icon="robot" href="/api/agents">
  Agent class hierarchy and methods
</Card>

<Card title="Configuration API" icon="gear" href="/api/configuration">
  Configuration system reference
</Card>

<Card title="GitHub" icon="github" href="https://github.com/darkresearch/fireteam">
  View source code
</Card>

</CardGroup>
